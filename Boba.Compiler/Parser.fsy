%{

open Boba.Compiler.Syntax
open Boba.Core.DotSeq

%}


%start unit

%token <Name> SMALL_NAME
%token <Name> BIG_NAME
%token <Name> OPERATOR_NAME
%token <Name> PREDICATE_NAME

%token <IntegerLiteral> INTEGER
%token <DecimalLiteral> DECIMAL
%token <StringLiteral> STRING

%token L_ANGLE  R_ANGLE
%token L_PAREN R_PAREN
%token L_BRACE R_BRACE
%token L_BRACKET R_BRACKET
%token L_ARROW R_ARROW
%token L_BIND R_BIND

%token SEMICOLON
%token COLON DOUBLE_COLON
%token PLUS MINUS
%token DOT
%token BAR DOUBLE_BAR
%token ELLIPSIS
%token EQUALS

%token IMPORT
%token AS
%token EXPORT
%token MAIN
%token DATA
%token RECURSIVE
%token PATTERN

%token LET
%token LOCAL
%token FUNCTION
%token WITH_STATE
%token NEW_REF
%token GET_REF
%token PUT_REF
%token UNTAG
%token HANDLE
%token AFTER
%token WITH
%token MATCH
%token DO
%token IF WHEN WHILE THEN ELSE

%type < Identifier > identifier
%type < Unit > unit

%%

unit : import_list decl_list main	{ UMain($1, $2, $3) }
	 | import_list decl_list export	{ UExport($1, $2, $3) }

import_list :						{ [] }
		    | import_list import	{ $2 :: $1 }

decl_list :							{ [] }
		  | decl_list declaration	{ $2 :: $1 }

main : MAIN EQUALS simple_expr	{ $3 }

import : IMPORT import_path AS SMALL_NAME				{ { Explicit = []; Path = $2; Alias = $4 } }
	   | IMPORT brace_names import_path AS SMALL_NAME	{ { Explicit = $2; Path = $3; Alias = $5 } }

import_path : STRING	{ IPLocal ($1) }
			| remote	{ IPRemote ($1) }

remote : SMALL_NAME DOT SMALL_NAME DOT SMALL_NAME COLON INTEGER DOT INTEGER DOT INTEGER
		 { { Org = $1; Project = $3; Unit = $5; Major = $7; Minor = $9; Patch = $11 } }

export : EXPORT brace_names	{ $2 }

brace_names : L_BRACE name_list R_BRACE	{ $2 }

name_list :					{ [] }
		  | name_list name	{ $2 :: $1 }

name : SMALL_NAME		{ $1 }
     | BIG_NAME			{ $1 }
	 | PREDICATE_NAME	{ $1 }



declaration : SMALL_NAME { DFunc ($1) }



term_statement_block : L_BRACE term_statement_list R_BRACE	{ $2 }

term_statement_list :												{ [] }
					| term_statement_list SEMICOLON term_statement	{ $3 :: $1 }

term_statement : LET pattern_expr_list							{ SLet ($2, []) }
			   | LET pattern_expr_list EQUALS simple_expr		{ SLet ($2, $4) }
			   | local_function									{ SLocals ([$1]) }
			   | RECURSIVE L_BRACE local_function_list R_BRACE	{ SLocals ($3) }
			   | simple_expr									{ SExpression ($1) }

local_function_list :										{ [] }
					| local_function_list local_function	{ $2 :: $1 }

local_function : LOCAL FUNCTION SMALL_NAME EQUALS simple_expr	{ { Name = $3; Body = $5 } }

simple_expr :					{ [] }
			| simple_expr word	{ $2 :: $1 }



word : term_statement_block				{ EStatementBlock ($1) }
	 | handle_word						{ $1 }
	 | match_word						{ $1 }
	 | if_word							{ $1 }
	 | when_word						{ $1 }
	 | while_word						{ $1 }
	 //| for_comprehension				{ EFor ($1) }
	 | function_literal					{ EFunctionLiteral ($1) }
	 //| tuple_literal					{ ETupleLiteral ($1) }
	 //| list_literal					{ EListLiteral ($1) }
	 //| vector_literal					{ EVectorLiteral ($1) }
	 //| slice_literal					{ ESliceLiteral ($1) }
	 //| dictionary_literal				{ EDictionaryLiteral ($1) }
	 //| record_literal					{ ERecordLiteral ($1) }
	 | PLUS SMALL_NAME					{ EExtension ($2) }
	 | MINUS SMALL_NAME					{ ERestriction ($2) }
	 | R_ARROW SMALL_NAME				{ ESelect ($2) }
	 //| record_update					{ EUpdate ($1) }
	 //| variant_literal					{ EVariantLiteral ($1) }
	 | DOUBLE_BAR SMALL_NAME			{ EEmbedding ($2) }
	 //| case_word							{ ECase ($1) }
	 | WITH_STATE term_statement_block	{ EWithState ($2) }
	 | NEW_REF							{ ENewRef }
	 | GET_REF							{ EGetRef }
	 | PUT_REF							{ EPutRef }
	 | UNTAG qualified_name 			{ EUntag ($2) }
	 | DO								{ EDo }

	 | INTEGER							{ EInteger ($1) }
	 | DECIMAL							{ EDecimal ($1) }
	 | STRING							{ EString ($1) }
	 | identifier						{ EIdentifier ($1) }

handle_word : HANDLE param_list term_statement_block WITH L_BRACE handler_list BAR return R_BRACE	{ EHandle ($2, $3, $6, $8) }
			| HANDLE param_list term_statement_block WITH L_BRACE handler_list R_BRACE				{ EHandle ($2, $3, $6, []) }

handler : BAR identifier param_list R_BIND simple_expr	{ { Name = $2; Params = $3; Body = $5; } }

return : AFTER simple_expr	{ $2 }

param_list :						{ [] }
		   | param_list SMALL_NAME	{ $2 :: $1 }

handler_list :									{ [] }
			 | handler_list SEMICOLON handler	{ $3 :: $1 }

match_word : MATCH L_BRACE match_clause_list R_BRACE								{ EMatch ($3, []) }
		   | MATCH L_BRACE match_clause_list BAR ELSE R_BIND simple_expr R_BRACE	{ EMatch ($3, $7) }

match_clause_list :	match_clause								{ [$1] }
				  | match_clause_list SEMICOLON match_clause	{ $3 :: $1 }

match_clause : BAR pattern_expr_list R_BIND simple_expr	{ { Matcher = $2; Body = $4 } }

if_word : IF simple_expr THEN term_statement_block ELSE term_statement_block	{ EIf ($2, $4, $6) }

when_word : WHEN simple_expr THEN term_statement_block	{ EIf ($2, $4, []) }

while_word : WHILE simple_expr THEN term_statement_block	{ EWhile ($2, $4) }

function_literal : L_PAREN simple_expr R_PAREN	{ $2 }

identifier : qualified_name L_ANGLE fixed_size_term_expr R_ANGLE	{ { Qualifier = List.take ($1.Length - 1) $1; Name = List.last $1; Size = Some ($3) } }
		   | qualified_name											{ { Qualifier = List.take ($1.Length - 1) $1; Name = List.last $1; Size = None } }

qualified_name : SMALL_NAME								{ [$1] }
			   | BIG_NAME								{ [$1] }
			   | OPERATOR_NAME							{ [$1] }
			   | SMALL_NAME DOUBLE_COLON qualified_name	{ $1 :: $3 }



pattern_expr_list :	pattern_expr					{ ind $1 SEnd }
				  | pattern_expr ELLIPSIS			{ dot $1 SEnd }
				  | pattern_expr_list pattern_expr	{ ind $2 $1 }

pattern_expr : INTEGER	{ PInteger ($1) }
			 | DECIMAL	{ PDecimal ($1) }
			 | STRING	{ PString ($1) }



fixed_size_term_expr : fixed_size_term_factor_list	{ $1 }

fixed_size_term_factor_list : fixed_size_term_factor									{ [$1] }
							| fixed_size_term_factor_list PLUS fixed_size_term_factor	{ $3 :: $1 }

fixed_size_term_factor : INTEGER			{ FixConst ($1) }
					   | SMALL_NAME			{ FixVar ($1) }
					   | INTEGER SMALL_NAME { FixCoeff ($1, $2) }