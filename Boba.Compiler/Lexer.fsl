{
open FSharp.Text.Lexing
open System
open Parser
open Boba.Compiler.Syntax
open Boba.Core.Types

let lexeme lexbuf = LexBuffer<_>.LexemeString lexbuf
}

let digit = ['0'-'9']
let whitespace = [' ' '\t' ]
let newline = ('\n' | '\r' '\n')

let lower = ['a'-'z']
let upper = ['A'-'Z']

rule token = parse
| whitespace		{ token lexbuf }
| newline			{ token lexbuf }
| ";"				{ SEMICOLON }
| ":"				{ COLON }
| "::"				{ DOUBLE_COLON }
| "+"				{ PLUS }
| "-"				{ MINUS }
| "."				{ DOT }
| "..."				{ ELLIPSIS }
| "="				{ EQUALS }
| "<"				{ L_ANGLE }
| ">"				{ R_ANGLE }
| "("				{ L_PAREN }
| ")"				{ R_PAREN }
| "["				{ L_BRACE }
| "]"				{ R_BRACE }
| "{"				{ L_BRACKET }
| "}"				{ R_BRACKET }
| "<-"				{ L_ARROW }
| "->"				{ R_ARROW }
| "<="				{ L_BIND }
| "=>"				{ R_BIND }
| "import"			{ IMPORT }
| "as"				{ AS }
| "export"			{ EXPORT }
| "main"			{ MAIN }
| "data"			{ DATA }
| "rec"				{ RECURSIVE }
| "pattern"			{ PATTERN }
| "let"				{ LET }
| "local"			{ LOCAL }
| "func"			{ FUNCTION }
| "with-state"		{ WITH_STATE }
| "new@"			{ NEW_REF }
| "get@"			{ GET_REF }
| "put@"			{ PUT_REF }
| "untag"			{ UNTAG }
| "handle"			{ HANDLE }
| "after"			{ AFTER }
| "with"			{ WITH }
| "match"			{ MATCH }
| "do"				{ DO }
| "if"				{ IF }
| "when"			{ WHEN }
| "then"			{ THEN }
| "else"			{ ELSE }
| "while"			{ WHILE }
| digit+			{ INTEGER ({ Value = lexeme lexbuf; Size = ISize; Position = lexbuf.StartPos }) }
| '"'[^'"']*'"'     { STRING ({ Value = lexeme lexbuf; Position = lexbuf.StartPos }) }
| lower(lower|upper|'-')*		{ SMALL_NAME ({ Name = lexeme lexbuf; Kind = ISmall; Position = lexbuf.StartPos }) }
| lower(lower|upper|'-')*'!'	{ OPERATOR_NAME ({ Name = lexeme lexbuf; Kind = ISmall; Position = lexbuf.StartPos }) }
| upper(lower|upper|'-')*		{ BIG_NAME ({ Name = lexeme lexbuf; Kind = ISmall; Position = lexbuf.StartPos }) }
| upper(lower|upper|'-')*'?'	{ PREDICATE_NAME ({ Name = lexeme lexbuf; Kind = ISmall; Position = lexbuf.StartPos }) }